\chapter{Introducción}

La programación competitiva combina dos asuntos:
(1) el diseño de algoritmos y (2) la implementación de algoritmos.

El \key{diseño de algoritmos} consiste de la resolución de problemas
y pensamiento matemático.
Se necesitan habilidades para analizar y resolver problemas creativamente.
Un algoritmo para resolver un problema
tiene que ser correcto y eficiente,
y a menudo la esencia del problema requiere
la invención de un algoritmo eficiente.

El conocimiento teórico de los algoritmos
es importante para los programadores competitivos.
Normalmente, una solución a un problema es
una combinación de técnicas conocidas y de
nuevas ideas. 
Las técnicas que aparecen en la programación competitiva
también forman la base para la investigación científica
de algoritmos.

La \key{implementación de algoritmos} requiere de buenas
habilidades en programación.
En la programación competitiva, las soluciones
son evaluadas utilizando un conjunto de casos de prueba
sobre un algoritmo implementado.
Por lo tanto, no es suficiente con que la idea del
algoritmo sea correcta, la implementación también
tiene que serlo.

En los concursos se utiliza un estilo de codificación sencillo y conciso.
Los programas deben escribirse rápidamente,
porque no hay mucho tiempo disponible.
A diferencia de la ingeniería de software tradicional,
los programas son cortos (cuando mucho 
unos cientos de líneas de código), y no necesitan
mantenimiento después del concurso.

\section{Lenguajes de programación}

\index{lenguaje de programación}

Al momento, los lenguajes de programación más populares
usados en los concursos son C++, Python y Java.
Por ejemplo, en el Google Code Jam 2017,
entre los 3,000 mejores participantes,
79 \% usaron C++,
16 \% usaron Python y
8 \% usaron Java \cite{goo17}.
Algunos participantes también utilizaron varios lenguajes de programación.

Mucha gente piensa que C++ es la mejor opción
para un programador competitivo,
y C++ casi siempre está disponible en todas
las plataformas de concursos.
Los beneficios de usar C++ son que
es un lenguaje muy eficiente y
su biblioteca estándar contiene una
gran colección
de estructuras de datos y algoritmos.

Por otro lado, es bueno
dominar varios lenguajes y comprender
sus puntos fuertes.
Por ejemplo, si se necesitan números enteros grandes
en el problema,
Python puede ser una buena opción, porque
incorpora operaciones específicas para
realizar cálculos con números enteros grandes.
Aún así, la mayoría de los problemas en los concursos de programación
están configurados para que
el uso de un lenguaje de programación específico
no sea una ventaja injusta.

Todos los programas de ejemplo de este libro están escritos en C++,
y a menudo se utilizan las estructuras de datos y algoritmos 
de su biblioteca estándar.
Los programas siguen el estándar C++11,
que se puede utilizar en la mayoría de los concursos hoy en día.
Si el lector aún no sabe programar en C++,
ahora es un buen momento para empezar a aprender.

\subsubsection{Plantilla de código de C++}

La siguiente es una típica plantilla de C++
en programación competitiva:

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // aqui viene la solucion
}
\end{lstlisting}

La línea \texttt{\#include} al inicio
del código es una característica del compilador \texttt{g++}
que nos permite incluir toda la biblioteca estándar.
Por lo tanto, no es necesario incluir bibliotecas 
por separado tales como \texttt{iostream},
\texttt{vector} y \texttt{algorithm},
sino que están disponibles automáticamente.

La línea \texttt{using} declara
que las clases y funciones
de la biblioteca estándar se pueden utilizar directamente
en el código.
Sin la línea \texttt{using} tendríamos que
escribir, por ejemplo, \texttt{std::cout},
pero ahora basta con escribir \texttt{cout}.

El código se puede compilar usando el siguiente comando:

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

Este comando produce el archivo binario \texttt{test}
a partir del código fuente \texttt{test.cpp}.
El compilador sigue el estándar C++11
(\texttt{-std=c++11}),
optimiza el código (\texttt{-O2})
y muestra advertencias sobre posibles errores  (\texttt{-Wall}).

\section{Entrada y salida}

\index{entrada y salida}

En la mayoría de los concursos, los flujos estándar se utilizan
para leer la entrada y escribir la salida.
En C++, los flujos estándar son
\texttt{cin} para entrada y \texttt{cout} para salida.
Además, se pueden utilizar las funciones
\texttt{scanf} y \texttt{printf} del lenguaje C.

La entrada del programa generalmente consiste en
números y cadenas que están separados por
espacios y nuevas líneas.
Se pueden leer desde el flujo de entrada \texttt{cin}
de la siguiente manera:

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}

Este tipo de código siempre funciona,
asumiendo que hay al menos un espacio
o nueva línea entre cada elemento de la entrada.
Por ejemplo, el código anterior puede leer
las siguientes entradas de la misma manera:
\begin{lstlisting}
123 456 monkey
\end{lstlisting}
\begin{lstlisting}
123    456
monkey
\end{lstlisting}
El flujo \texttt{cout} se utiliza para la salida
de la siguiente manera:
\begin{lstlisting}
int a = 123, b = 456;
string x = "monkey";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

A veces, la entrada y la salida
son un cuello de botella en el programa.
Las siguientes líneas al inicio del programa
hacen que la entrada y la salida sean más eficientes:

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

Se debe tener en cuenta que la nueva línea \texttt{"\textbackslash n"}
funciona más rápido que \texttt{endl},
porque \texttt{endl} siempre causa una
operación de vaciado del búfer.

Las funciones de C \texttt{scanf}
y \texttt{printf} son una alternativa
a los flujos estándar de C++.
Suelen ser un poco más rápidas
pero también son más difíciles de usar.
El siguiente código lee dos números enteros de la entrada:
\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}
El siguiente código imprime dos enteros:
\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}

A veces, el programa debe leer una línea completa
de la entrada, posiblemente conteniendo espacios.
Esto se puede lograr utilizando
la función \texttt{getline}:

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

Si se desconoce la cantidad de datos, el siguiente
ciclo es muy útil:
\begin{lstlisting}
while (cin >> x) {
    // codigo
}
\end{lstlisting}
Este ciclo lee elementos de la entrada
uno tras otro, hasta que no haya
más datos disponibles en la entrada.

Algunas plataformas de concursos utilizan archivos para
entrada y salida.
Una solución fácil para esto es escribir
el código como de costumbre usando flujos estándar,
pero agregando las siguientes líneas al principio del código:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
Después de esto, el programa lee la entrada del archivo
''input.txt'' y escribe la salida en el archivo
''output.txt''.

\section{Trabajando con números}

\index{entero}

\subsubsection{Enteros}

El tipo de entero más utilizado en programación competitiva
es \texttt{int}, el cual consta de 32 bits que proporcionan
un rango de valores de $-2^{31} \ldots 2^{31}-1$
o cerca de $-2 \cdot 10^9 \ldots 2 \cdot 10^9$.
Si el tipo \texttt{int} no es suficiente,
se puede utilizar el tipo \texttt{long long} de 64 bits.
Éste tiene un rango de valores de $-2^{63} \ldots 2^{63}-1$
o cerca de $-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$.

El siguiente código define una variable
\texttt{long long}:
\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}
El sufijo \texttt{LL} significa que el
tipo de dato del número es \texttt{long long}.

Un error común cuando se usa el tipo \texttt{long long}
es que el tipo \texttt{int} todavía se utilice 
en algún otro lugar.
Por ejemplo, el siguiente código continue
un error muy sutil:

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

Aunque la variable \texttt{b} es de tipo \texttt{long long},
ambos números en la expresión \texttt{a*a}
son de tipo \texttt{int} y el resultado
también es de tipo \texttt{int}.
Debido a esto, la variable \texttt{b}
contendrá un resultado equivocado.
El problema se puede resolver cambiando el tipo
de la variable \texttt{a} por \texttt{long long} o
cambiando la expresión por \texttt{(long long)a*a}.

Por lo general, los problemas del concurso se establecen de manera que
el tipo \texttt{long long} sea suficiente.
Aun así, es bueno saber que
el compilador \texttt{g++} también provee
un tipo \texttt{\_\_int128\_t} de 128 bits
con un rango de valores de
$-2^{127} \ldots 2^{127}-1$ o cerca de $-10^{38} \ldots 10^{38}$.
Sin embargo, este tipo de dato no está disponible en todas las plataformas de concursos.

\subsubsection{Aritmética modular}

\index{residuo}
\index{aritmética modular}

Denotamos a $x \bmod m$ como el residuo
cuando $x$ es dividido por $m$.
Por ejemplo, $17 \bmod 5 = 2$,
porque $17 = 3 \cdot 5 + 2$.

A veces, la respuesta a un problema es un
un número muy grande pero es suficiente
imprimirlo ''módulo $m$'', es decir,
el residuo cuando la respuesta es dividida por $m$
(por ejemplo, ''módulo $10^9+7$'').
La idea es que incluso si la respuesta
es muy grande,
es suficiente utilizar los tipos
\texttt{int} y \texttt{long long}.

Una propiedad importante del residuo es que
en las operaciones de suma, resta y multiplicación,
el residuo se puede realizar antes de la operación:

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

Por lo tanto, podemos aplicar el residuo después de cada operación
y los números nunca serán demasiado grandes.

Por ejemplo, el siguiente código calcula $n!$,
el factorial de $n$, módulo $m$:
\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n; i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

Por lo general, queremos que el residuo siempre
esté entre $0\ldots m-1$.
Sin embargo, en C++ y otros lenguajes,
el residuo de un número negativo
es cero o negativo.
Una forma sencilla de asegurarse
que no hay residuos negativos es primero calcular
el residuo como siempre y sumarle $m$
si el resultado es negativo:
\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}
Sin embargo, esto solo es necesario cuando hay
restas en el código y
el residuo puede volverse negativo.

\subsubsection{Números de punto flotante}

\index{número de punto flotante}

Los tipos de dato de punto flotante más comunes en
programación competitiva son
el \texttt{double} de 64 bits
y, como una extensión en el compilador \texttt{g++},
el \texttt{long double} de 80 bits.
En la mayoría de los casos, \texttt{double} es suficiente,
pero \texttt{long double} es más preciso.

La precisión requerida de la respuesta 
generalmente se da en el enunciado del problema.
Una forma sencilla de generar la respuesta es utilizar
la función \texttt{printf}
y dar el número de lugares decimales
en la cadena de formato.
Por ejemplo, el siguiente código imprime
el valor de $x$ con 9 decimales:

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

Una dificultad al usar números de punto flotante
es que algunos números no se pueden representar
exactamente como tal,
y habrá errores de redondeo.
Por ejemplo, el resultado del siguiente código
es sorprendente:

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

Debido a un error de redondeo,
el valor de \texttt{x} es un poco menor que 1,
mientras que el valor correcto sería 1.

Es arriesgado comparar números de punto flotante
con el operador \texttt{==},
porque es posible que aunque los valores son iguales 
al final de cuentas no lo sean debido a errores de precisión.
Una mejor manera de comparar números de punto flotante
es asumir que dos números son iguales
si la diferencia entre ellos es menor que $\varepsilon$,
donde $\varepsilon$ es un número pequeño.

En la práctcia, los números se pueden comparar
de la siguiente manera ($\varepsilon=10^{-9}$):

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a y b son iguales
}
\end{lstlisting}

Se debe tener en cuenta que aunque los números de punto flotante son inexactos,
los números enteros todavía pueden ser
representados con precisión hasta un cierto límite.
Por ejemplo, usando \texttt{double},
es posible representar con precisión todos
los enteros cuyo valor absoluto sea como máximo $2^{53}$.

\section{Abreviando el código}

El código abreviado es ideal en la programación competitiva,
porque los programas deben ser escritos
tan rápido como sea posible.
Debido a esto, los programadores competitivos a menudo definen
nombres más cortos para tipos de datos y otras partes del código.

\subsubsection{Nombres de tipo}
\index{tuppdef@\texttt{typedef}}
Usando el comando \texttt{typedef}
es posible dar un nombre más corto
a un tipo de dato.
Por ejemplo, el nombre \texttt{long long} es largo,
así que podemos definir un nombre más corto \texttt{ll}:
\begin{lstlisting}
typedef long long ll;
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
se puede abreviar de la siguiente manera:
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

El comando \texttt{typedef}
también se puede utilizar con tipos más complejos.
Por ejemplo, el siguiente código establece
el nombre \texttt{vi} para un vector de enteros
y el nombre \texttt{pi} para un par
que contiene dos enteros.
\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{Macros}
\index{macro}
Otra forma de acortar el código es mediante
\key{macros}.
Una macro significa que ciertas cadenas en
el código se cambiarán antes de la compilación.
En C++, las macros se definen utilizando la
palabra clave \texttt{\#define}.

Por ejemplo, podemos definir las siguientes macros:
\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
puede abreviarse de la siguiente manera:
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

Una macro también puede tener parámetros
que permiten abreviar ciclos y otras
estructuras de control.
Por ejemplo, podemos definir la siguiente macro:
\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
puede abreviarse de la siguiente manera:
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

A veces, las macros causan errores que pueden resultar difíciles
detectar. Por ejemplo, considere la siguiente macro
que calcula el cuadrado de un número:
\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
Esta macro \emph{no} siempre funciona como se espera.
Por ejemplo, el código
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corresponde al código
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

Una mejor versión de la macro es la siguiente:
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
Ahora el código
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corresponde al código
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}


\section{Matemáticas}

Las matemáticas tienen un papel importante en la programación
competitiva, y no es posible convertirse en
un programador competitivo exitoso sin
tener buenas habilidades matemáticas.
En esta sección se analizan algunos
conceptos matemáticos y fórmulas que
se necesitan más adelante en el libro.

\subsubsection{Fórmulas de sumas}

Cada suma de la forma
\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
donde $k$ es un enero positivo,
tiene una fórmula de forma cerrada que es un
polinomio de grado $k+1$.
Por ejemplo\footnote{\index{fórmula de Faulhaber}
Incluso existe una fórmula general para tales sumas, llamada \key{fórmula de Faulhaber},
pero es demasiado compleja para presentarla aquí.},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
y
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

Una \key{progresión aritmética} es una \index{progresión aritmética}
secuencia de números
donde la diferencia entre dos números consecutivos
es constante.
Por ejemplo,
\[3, 7, 11, 15\]
es una progresión aritmética con constante 4.
Se puede calcular la suma de una progresión aritmética
usando la fórmula
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{números}} = \frac{n(a+b)}{2}\]
donde $a$ es el primer número,
$b$ es el último número y
$n$ es la cantidad de números.
Por ejemplo,
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
La fórmula se basa en el hecho
de que la suma consta de $n$ números y
el valor de cada número es $(a+b)/2 $ en promedio.

\index{progresión geométrica}
Una \key{progresión geométrica} es una secuencia
de números
donde la relación entre dos números consecutivos
es constante.
Por ejemplo,
\[3,6,12,24\]
es una progresión geométrica con constante 2.
La suma de una progresión geométrica se puede calcular
usando la fórmula
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
donde $a$ es el primer número,
$b$ es el último número y la
relación entre números consecutivos es $k$.
Por ejemplo,
\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]

Esta fórmula se puede derivar de la siguiente manera. Sea
\[ S = a + ak + ak^2 + \cdots + b .\]
Al multiplicar ambos lados por $k$, obtenemos
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\]
y resolviendo la ecuación
\[ kS-S = bk-a\]
produce la fórmula.

Un caso especial de suma de una progresión geométrica es la fórmula
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{suma armónica}

Una \key{suma armónica} es una suma de la forma
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]

Un límite superior para una suma armónica es $\log_2(n)+1$.
Es decir, podemos
modificar cada término $1/k$ de tal manera que $k$ se convierte en
la potencia más cercana de dos que no excede $k$.
Por ejemplo, cuando $n=6$, podemos estimar
la suma como sigue:
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
Este límite superior consta de $\log_2(n)+1$ partes
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$, etc.),
y el valor de cada parte es como máximo 1.

\subsubsection{Teoría de conjuntos}

\index{teoría de conjuntos}
\index{conjunto}
\index{intersección}
\index{unión}
\index{diferencia}
\index{subconjunto}
\index{conjunto universal}
\index{complemento}

Un \key{conjunto} es una colección de elementos.
Por ejemplo, el conjunto
\[X=\{2,4,7\}\]
contiene los elementos 2, 4 y 7.
El símbolo $\emptyset$ denota un conjunto vacío,
y $|S|$ denota el tamaño de un conjunto $S$,
es decir, el número de elementos en el conjunto.
Por ejemplo, en el conjunto anterior, $|X|=3$.

Si un conjunto $S$ contiene un elemento $x$,
escribimos $x \in S$,
de lo contrario escribimos $x \notin S$.
Por ejemplo, en el conjunto anterior
\[4 \in X \hspace{10px}\textrm{y}\hspace{10px} 5 \notin X.\]

\begin{samepage}
Se pueden construir nuevos conjuntos usando operaciones de conjuntos:
\begin{itemize}
\item La \key{intersección} $A \cap B$ consiste de elementos
que están en ambos $A$ y $B$.
Por ejemplo, si $A=\{1,2,5\}$ y $B=\{2,4\}$,
entonces $A \cap B = \{2\}$.
\item La \key{unión} $A \cup B$ consiste de elementos
que están en $A$ o en $B$ o en ambos.
Por ejemplo, si $A=\{3,7\}$ and $B=\{2,3,8\}$,
entonces $A \cup B = \{2,3,7,8\}$.
\item El \key{complemento} $\bar A$ consiste de elementos
que no están en $A$.
La interpretación de un complemento depende de
el \key{conjunto universal}, que contiene todos los elementos posibles.
Por ejemplo, si $A=\{1,2,5,7\}$ y el conjunto universal es
$\{1,2,\ldots,10\}$, entonces $\bar A = \{3,4,6,8,9,10\}$.
\item La \key{diferencia} $A \setminus B = A \cap \bar B$
consiste de elementos que están en $A$ pero no en $B$.
Tenga en cuenta que $B$ puede contener elementos que no están en $A$.
Por ejemplo, si $A=\{2,3,7,8\}$ y $B=\{3,5,8\}$,
entonces $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

Si cada elemento de $A$ también pertenece a $S$,
podemos decir que $A$ es un \key{subconjunto} de $S$,
denotado por $A \subset S$.
Un conjunto $S$ siempre tiene $2^{|S|}$ subconjuntos,
incluyendo el conjunto vacío.
Por ejemplo, los subconjuntos del conjunto $\{2,4,7\}$ son
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ and $\{2,4,7\}$.
\end{center}

Algunos conjuntos de uso frecuente son
$\mathbb{N}$ (números naturales),
$\mathbb{Z}$ (enteros),
$\mathbb{Q}$ (números racionales) y
$\mathbb{R}$ (números reales).
El conjunto $\mathbb{N}$
se puede definir de dos formas, dependiendo
sobre la situación:
cualquiera de $\mathbb{N}=\{0,1,2,\ldots\}$
o $\mathbb{N}=\{1,2,3,...\}$.

También podemos construir un conjunto usando una regla de la forma
\[\{f(n) : n \in S\},\]
donde $f(n)$ es alguna función.
Este conjunto contiene todos los elementos de la forma $f(n)$,
donde $n$ es un elemento en $S$.
Por ejemplo, el conjunto
\[X=\{2n : n \in \mathbb{Z}\}\]
contiene todos los enteros pares

\subsubsection{Lógica}

\index{lógica}
\index{negación}
\index{conjunción}
\index{disyunción}
\index{implicación}
\index{equivalencia}

El valor de una expresión lógica es
\key{true} (1) o \key{false} (0).
Los operadores lógicos más importantes son
$\lnot$ (\key{negación}),
$\land$ (\key{conjunción}),
$\lor$ (\key{disyunción}),
$\Rightarrow$ (\key{implicación}) y
$\Leftrightarrow$ (\key{equivalencia}).
La siguiente tabla muestra los significados de estos operadores:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

La expresión $\lnot A$ tiene el valor opuesto de $A$.
La expresión $A \land B$ es verdadera si ambos $A$ y $B$
son verdaderos,
y la expresión $A \lor B$ es verdadera si $A$ o $B$ o ambos
son verdaderos.
La expresión $A \Rightarrow B$ es verdadera
si cuando $A$ es verdadera, también $B$ es verdadera.
La expresión $A \Leftrightarrow B$ es verdadera
si $A$ y $B$ son ambas verdaderas o ambas falsas.

\index{predicado}

Un \key{predicado} es una expresión que es verdadera o falsa
dependiendo de sus parámetros.
Los predicados generalmente se denotan con letras mayúsculas.
Por ejemplo, podemos definir un predicado $P(x)$
que sea verdadero exactamente cuando $x$ sea un número primo.
Usando esta definición, $P(7)$ es verdadero pero $P(8)$ es falso.

\index{cuantificador}

Un \key{cuantificador} conecta una expresión lógica
a los elementos de un conjunto.
Los cuantificadores más importantes son
$\forall$ (\key{para todo}) y $\exists$ (\key{existe}).
Por ejemplo,
\[\forall x (\exists y (y < x))\]
significa que por cada elemento $x$ en el conjunto,
existe un elemento $y$ en el conjunto
tal que $y$ es más pequeño que $x$.
Esto es cierto en el conjunto de números enteros,
pero falso en el conjunto de los números naturales.

Usando la notación descrita anteriormente,
podemos expresar muchos tipos de proposiciones lógicas.
Por ejemplo,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\]
significa que si un número $x$ es mayor que 1
y no es un número primo,
entonces existen números $a$ y $b$
que son mayores que $1$ y cuyo producto es $x$.
Esta proposición es verdadera en el conjunto de números enteros.

\subsubsection{Funciones}

La función $\lfloor x \rfloor$ redondea el número $x$
hacia el entero inmediato inferior, y la función
$\lceil x \rceil$ redondea el número $x$
hacia el entero inmediato superior. Por ejemplo,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{and} \hspace{10px} \lceil 3/2 \rceil = 2.\]

Las funciones $\min(x_1,x_2,\ldots,x_n)$
y $\max(x_1,x_2,\ldots,x_n)$
dan el más pequeño y más grande de los valores
$x_1,x_2,\ldots,x_n$.
Por ejemplo,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{y} \hspace{10px} \max(1,2,3)=3.\]

\index{factorial}

El \key{factorial} $n!$ se puede definir como
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
o recursivamente
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{número de Fibonacci}

Los \key{números de Fibonacci}
%\footnote{Fibonacci (c. 1175--1250) was an Italian mathematician.}
surgen en muchas situaciones.
Estos números pueden definirse recursivamente de la siguiente manera:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
Los primeros números de Fibonacci son
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
También hay una fórmula de forma cerrada
para calcular los números de Fibonacci, que a veces se llama
\index{fórmula de Binet} \key{fórmula de Binet}:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Logaritmos}

\index{logaritmo}

El \key{logaritmo} de un número $x$
se denota $\log_k(x)$, donde $k$ es la base
del logaritmo.
Según la definición,
$\log_k(x)=a$ exactamente cuando $k^a=x$.

Una propiedad útil de los logaritmos es
que $\log_k(x)$ es igual al número de veces que
se debe dividir $x$ por $k$ antes de obtener 
el número 1.
Por ejemplo, $\log_2(32)=5$
porque se requieren 5 divisiones por 2:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

Los logaritmos se utilizan a menudo en el análisis de
algoritmos, porque muchos algoritmos eficientes
reducen algo a la mitad en cada paso.
Por tanto, podemos estimar la eficiencia de tales algoritmos
usando logaritmos.

El logaritmo de un producto es
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
y consecuentemente,
\[\log_k(x^n) = n \cdot \log_k(x).\]
Además, el logaritmo de un cociente es
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Otra fórmula útil es
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
y usando esto, es posible calcular
logaritmos a cualquier base si hay una manera de
calcular logaritmos a una base fija.

\index{logaritmo natural}

El \key{logaritmo natural} $\ln(x)$ de un número $x$
es un logaritmo cuya base es $e \approx 2.71828$.
Otra propiedad de los logaritmos es que
el número de dígitos de un entero $x$ en base $b$ es
$\lfloor \log_b(x)+1 \rfloor$.
Por ejemplo, la representación de
$123$ en base $2$ es 1111011 y
$\lfloor \log_2(123)+1 \rfloor = 7$.

\section{Concursos y recursos}

\subsubsection{IOI}

La Olimpiada Internacional de Informática (IOI por sus siglas en inglés)
es un concurso de programación anual para
estudiantes de escuela secundaria y preparatoria.
Cada país puede enviar un equipo de
cuatro estudiantes al concurso.
Suele haber unos 300 participantes
de 80 países.

La IOI consta de dos concursos de cinco horas de duración.
En ambos concursos, los participantes tienen que
resolver tres tareas algorítmicas de diversa dificultad.
Las tareas se dividen en subtareas,
cada uno de los cuales tiene una puntuación asignada.
Incluso si los concursantes se dividen en equipos,
compiten de manera individual.

El programa de estudios del IOI \cite{iois} establece los temas
que pueden aparecer en las tareas.
Casi todos los temas del programa de estudios del IOI
están cubiertos por este libro.

Los participantes del IOI se seleccionan mediante
concursos nacionales.
Antes del IOI, se organizan muchos concursos regionales,
como la Olimpiada Báltica de Informática (BOI),
la Olimpiada Centroeuropea de Informática (CEOI)
y la Olimpiada de Informática de Asia y el Pacífico (APIO).

Algunos países organizan concursos de práctica en línea
para los futuros participantes de la IOI,
tales como el Concurso Abierto Croata de Informática \cite{coci}
y la Olimpiada de Computación de Estados Unidos \cite{usaco}.
Además, una gran colección de problemas de concursos polacos
está disponible en línea \cite{main}.

\subsubsection{ICPC}

El Concurso Internacional de Programación Universitaria (ICPC por sus siglas en inglés)
es un concurso anual de programación para estudiantes universitarios.
Cada equipo consta de tres estudiantes,
y a diferencia del IOI, los estudiantes trabajan juntos;
solo hay una computadora disponible para cada equipo.


El ICPC consta de varias etapas, y
los mejores equipos son invitados a la Final Mundial.
Si bien hay decenas de miles de participantes
en el concurso, solo hay un pequeño número \footnote{El número exacto de lugares
disponibles puede variar de un año a otro; en 2017, hubo 133 lugares en la final.} de lugares disponibles en la final,
así que incluso avanzar a la final
ya es un gran logro en algunas regiones del mundo.

En cada concurso del ICPC, los equipos tienen cinco horas para
resolver alrededor de diez problemas de algoritmos.
Se acepta una solución a un problema solo si se resuelven
todos los casos de prueba de manera eficiente.
Durante el concurso, los competidores pueden ver los resultados de otros equipos,
pero durante la última hora el marcador está congelado y
no es posible ver los resultados de los últimos envíos.

Los temas que pueden aparecer en el ICPC no están tan bien
especificados como los del IOI.
En cualquier caso, está claro que en el ICPC se necesitan 
más conocimientos, especialmente más habilidades matemáticas.

\subsubsection{Concursos en línea}

También hay muchos concursos en línea que están al alcance de todos.
Por el momento, el sitio de concursos más activo es Codeforces,
que organiza concursos cada semana.
En Codeforces, los participantes se dividen en dos divisiones:
los principiantes compiten en la división Div2 y los más experimentados en la división Div1.
Otros sitios de concursos incluyen AtCoder, CS Academy, HackerRank y Topcoder.

Algunas empresas organizan concursos en línea con finales presenciales.
Ejemplos de tales concursos son Facebook Hacker Cup,
Google Code Jam y Yandex.Algorithm.
Por supuesto, las empresas también utilizan esos concursos para reclutar:
obtener un buen desempeño en un concurso es una buena manera de demostrar sus habilidades.

\subsubsection{Libros}

Hay algunos libros (además de este) que
se enfocan en la programación competitiva y la resolución algorítmica de problemas:

\begin{itemize}
\item S. S. Skiena y M. A. Revilla:
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim y F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

Los dos primeros libros están destinados a principiantes,
mientras que el último libro contiene material avanzado.

Por supuesto, los libros de algoritmos en general también son adecuados para
programadores competitivos.
Algunos libros populares son:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest y C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg y É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
